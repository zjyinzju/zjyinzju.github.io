# 树
-----------------------------------
## 概念
### 定义
+ 树是n(n>=0)个结点的有限集合，n=0时称为空树
+ 在任意一棵非空树中，有且仅有一个特定的称为**根(root)**的结点
+ 当n>1时，其余结点可分为m(m>0)个*互不相交*的有限集合T1、T2、...、Tm，其中每一个集合本身又是一棵树，并称为根的**子树(subtree)**（换言之，除了根结点外，每个结点都有且仅有一个父结点）
+ 树由一个根结点和0个或多个非空的子树组成，这些子树与根通过一条有向的**边(edge)**连接，一棵N个结点的树有N-1条边

### 术语
+ 结点的**度(degree)**：结点拥有的子树的个数
+ 树的度：树所有节点中最大的度数
+ **叶结点（Leaf）**：度为零的结点
+ **分支结点（Branch）**：度不为零的结点
+ **父结点（Parent）**：有子树的结点是其子树的根结点的父结点
+ **子结点（Child）**：若A结点是B结点的父结点，则称B结点是A结点的子结点
+ **兄弟结点（Sibling）**：具有相同父结点的结点互称为兄弟结点
+ **祖先结点（Ancestor）**：从根到某结点所经分支上的所有结点
+ **子孙结点（Descendant）**：以某结点为根的子树中任一结点
+ **路径（Path）**：从结点n1到nk的路径是一个结点序列n1, n2, ..., nk，使得ni是ni+1的父结点
+ **路径长度**：路径上的边数
+ **结点的层次（Level）**：规定根结点在第一层，其子结点在第二层，以此类推
+ **树的高度/深度（Depth）**：树中结点的最大层次
+ **结点的高度**：从结点到叶结点的最长路径的边数
+ **结点的深度**：从根到该结点的路径长度

-----------------------------------
## 实现
+ 数组实现较难实现树的一些复杂结构
+ 链表实现可行但是空间浪费较大
+ 这里使用FirstChild_NextSibling Representation实现树
```c
typedef struct TreeNode *PtrToNode;
struct Tree Node {
    // 结点元素
    ElementType Element;
    // 指向第一个子结点
    PtrToNode FirstChild;
    // 指向下一个兄弟结点
    PtrToNode NextSibling;
};
```
将这种方法表示的树顺时针旋转45°，得到类似二叉树的结构

-----------------------------------

## 二叉树
### 定义
+ 二叉树是n(n>=0)个结点的有限集合，它或者是空集（n=0），或者由一个根结点及两棵互不相交的。分别称为这个根的左子树和右子树的二叉树组成
+ 二叉树是每个结点**最多有两个子树**的树结构
+ 二叉树的子树有左右之分，次序不能颠倒

### 术语
+ **满二叉树（Perfect Binary Tree）**：每个结点的度都是0或2
+ **斜二叉树（Skewed Binary Tree）**：所有结点只有左子树或右子树的二叉树
+ **完全二叉树（Complete Binary Tree）**：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。
（亦即，完全二叉树是满二叉树或者满二叉树按序去掉最后的一些节点）

### 性质
+ 在二叉树的第i层上至多有$2^{i-1}$个结点$(i>=1)$
+ 深度为k的二叉树至多有$2^k-1$个结点$(k>=1)$
+ 对任何一棵二叉树T，如果其叶结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$
+ 具有n个结点的完全二叉树的深度为$\log_2[n]+1$，其中$[x]$表示不大于x的最大整数

### 遍历

#### 代码实现
>根本问题：二维结构线性化

+ **先序遍历**：根-左-右
    ```c
    // it is recursive
    void PreOrderTraversal( BinTree BT ) {
        if( BT ) {
            // visit root
            printf("%d\n", BT->Data);
            // traverse left subtree
            PreOrderTraversal( BT->Left );
            // traverse right subtree
            PreOrderTraversal( BT->Right );
        }
    }
    ```
+ **中序遍历**：左-根-右
    
    === "递归实现"   
    
        ```c
            void InOrderTraversal( BinTree BT ) {
            if( BT ) {
                // traverse left subtree
                InOrderTraversal( BT->Left );
                // visit root
                printf("%d\n", BT->Data);
                // traverse right subtree
                InOrderTraversal( BT->Right );
            }
        }
        ```
    === "迭代实现（堆栈）"
        
        ```c
            void InOrderTraversal( BinTree BT){
                BinTree T = BT;
                // create and initialize a stack
                Stack S = CreateStack( MaxSize );
                // traverse the tree
                while ( T || !IsEmpty(S) ){
                    // traverse left subtree
                    while ( T ) {
                        // push the node into the stack
                        Push( S, T );
                        T = T->Left;
                    }
                    if( !IsEmpty(S) ) {
                        // pop the node from the stack
                        T = Pop( S );
                        printf("%d\n", T->Data);
                        // traverse right subtree
                        T = T->Right;
                    }
                }
            }
        ```

+ **后序遍历**：左-右-根
    ```c
    // it is recursive
    void PostOrderTraversal( BinTree BT ) {
        if( BT ) {
            // traverse left subtree
            PostOrderTraversal( BT->Left );
            // traverse right subtree
            PostOrderTraversal( BT->Right );
            // visit root
            printf("%d\n", BT->Data);
        }
    }
    ```
+ **层序遍历**：按层次从上到下，从左到右
>队列实现：根结点入队，然后开始循环：出队一个结点，访问该结点，将其左右孩子入队

    ```c
    void LevelOrderTraversal( BinTree BT ) {
        Queue Q;
        BinTree T;
        // if the tree is empty, return
        if( !BT ) return;
        // create a queue and initialize it
        Q = CreateQueue();
        AddQ( Q, BT );
        while( !IsEmpty(Q) ) {
            // when the queue is not empty, dequeue a node
            T = DeleteQ( Q );
            // visit the node
            printf("%d\n", T->Data);
            // if the node has left or right child, enqueue them
            if( T->Left ) AddQ( Q, T->Left );
            if( T->Right ) AddQ( Q, T->Right );
        }
    }
    ```

#### 应用
+ 输出叶结点：先序，print前加if判断
+ 求二叉树高度：后序，返回左右子树高度的最大值+1
+ 二元运算表达式树的计算：先序、中序、后序遍历得到前缀、中缀、后缀表达式。注意：中缀表达式需要在每个左子树输出完成后加括号以保证运算优先级一致
+ 由中序和另外任一遍历序列，可以唯一确定一棵二叉树 

### 储存结构
+ 顺序存储：将二叉树按照**完全二叉树**的方式存储在数组中。若结点的序号为i，则：
    + 其左孩子的序号为2i，（若$2i \le n$,则无左孩子）
    + 右孩子的序号为2i+1，（同上）
    + 父结点的序号为$\lfloor i/2 \rfloor$
对一般二叉树也可用这种方式存储，但会浪费空间（无结点处为空）
+ 链表储存
    ```c
    typedef struct TreeNode *PtrToNode;
    struct TreeNode {
        ElementType Data;
        PtrToNode Left;
        PtrToNode Right;
    };
    typedef PtrToNode BinTree;
    ```