# 图(Graph)
------------------------

## 基础概念
+ 表示为**G(V, E)**，其中V是顶点集合，E是边集合
+ **有向图**(Directed Graph)：边有方向，E中的元素表示为<u, v>
+ **无向图**(Undirected Graph)：边无方向，E中的元素表示为(u, v)
    + v和u之间有边，则称v和u是邻接的(adjacent)
    + v和u之间有一条无向边，则称(v, u) is incident on v and u
    + v和u之间有一条有向边(u $\rightarrow$ v)，则称v is adjacent **to** u, u is adjacent **from** v
+ 不考虑自环(self loop)和重边(Multiple Edge)
+ **完全图**(Complete Graph)：任意两个顶点之间都有边
+ **子图**(Subgraph)：G' = (V', E')是G的子图，当且仅当V'是V的子集，E'是E的子集
+ **路径**(Path)：顶点序列v1, v2, ..., vk
    + **简单路径**(Simple Path)：除了起点和终点外，其他顶点不重复
    + 路径长度：路径经过边的数量
+ **回路**(Cycle)：起点和终点相同的路径
+ 对于无向图：
    + 如果图中任意两个顶点之间都有路径，则称图是**连通的(Connected)**
    + **连通分量**(Connected Component)：无向图的极大连通子图
+ 对于有向图：
    + **强连通**(Strongly Connected)：任意两个顶点之间都有路径
    + **强连通分量**(Strongly Connected Component)：有向图的极大强连通子图
    + **弱连通**(Weakly Connected)：有向图的基础图（将有向边替换为无向边）是连通的
+ **DAG**(Directed Acyclic Graph)：有向无环图
+ **树**(Tree)：无向图，连通且无回路
+ **度数**(Degree)：顶点的度数是与该顶点相关联的边的数量
    + **入度**(In-Degree)：有向图中指向该顶点的边的数量
    + **出度**(Out-Degree)：有向图中从该顶点出发的边的数量
    + 边的数量 = 所有节点的度数之和 除以2

## 表示
+ **邻接矩阵**(Adjacency Matrix)：
V 个顶点从0开始编号，构成V x V的矩阵，A[i][j]表示顶点i和j之间是（1）否（0）有边
    + 无向图：对称矩阵，且对角元都为 0
        - 改进：只存下三角(或上三角)，此时A[i][j]数组索引为`i(i+1)/2+j`
    + 有向图：可能为非对称矩阵
    + 稠密图(Dense Graph)：边数接近V^2
    + 稀疏图(Sparse Graph)：边数接近V（空间需求为$\Theta$($V^2$)
    + 度数：对于无向图，第i行或第i列的和；对于有向图，第i**行的和为出度**，第i**列的和为入度**
+ **邻接表**(Adjacency List)：每个顶点v有一个链表，存储与v邻接的顶点
    + 对于有向图，链表中存储的是出边；如果要遍历入度则需要额外储存一个链表
    + 对于无向图，链表中存储的是邻接的顶点，这样会将每个边储存两次
    + 优点：节省空间，对于稀疏图更好，空间需求为$\Theta$(V+E) 
+ **带权图/网络**(Weighted Graph)：边有权值
    + 邻接矩阵：A[i][j]表示顶点i和j之间的权值
    + 邻接表：链表中存储的是边的权值

## 遍历
+ DFS: 深度优先——无路可走时回溯
```c
void DFS(int v) {
    visited[v] = true;
    for (int w = FirstNeighbor(v); w >= 0; w = NextNeighbor(v, w)) {
        if (!visited[w]) {
            DFS(w);
        }
    }
}
```
+ BFS: 广度优先——层层外扩
```c
void BFS(Vertex v) {
    visited[v] = true;
    Enqueue(v, Q);
    while (!IsEmpty(Q)) {
        v = Dequeue(Q);
        for (int w = FirstNeighbor(v); w >= 0; w = NextNeighbor(v, w)) {
            if (!visited[w]) {
                visited[w] = true;
                Enqueue(w, Q);
            }
        }
    }
}
```

## 拓扑排序
+ AOV 网络：Active on vertex
+ 拓扑序：AOV中从V到W有一条有向路径，则V在W之前
+ AOV若为合理的拓扑序，则必为**有向无环图**
+ 拓扑排序：对有向无环图进行排序，使得所有边的起点在终点之前
    + 有向无环图的拓扑排序不唯一
    + 有向无环图的拓扑排序不一定存在
+ 拓扑排序算法：
    + 从入度为0的顶点开始，每次删除一个顶点和与之关联的边
    + 若图中还有顶点，则图中有回路
```c
void TopSort(Graph G) {
    int cnt = 0;
    for (int i = 0; i < G->Nv; i++) {
        if (indegree[i] == 0) {
            Enqueue(i, Q); // 入度为0的顶点入队
        }
    }
    while (!IsEmpty(Q)) {
        v = Dequeue(Q); // 出队
        print v;
        cnt++;// 计数
        for (int w = FirstNeighbor(v); w >= 0; w = NextNeighbor(v, w)) {
            if (--indegree[w] == 0) { // 入度减1同时判断是否为0
                Enqueue(w, Q);
            }
        }
    }
    if (cnt != G->Nv) {
        printf("图中有回路");
    }
```
